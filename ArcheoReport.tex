\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{float}
\usepackage[margin=1in,includefoot]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\footrulewidth}{1pt}

\begin{document}

\begin{titlepage}
	\begin{center}
	\begin{figure}[t]
	\hspace*{0.35cm}\includegraphics[width=1.0\textwidth]{uclLogo}\\
	\end{figure}
	\line(1,0){300}\\
	[0.25in]
	\huge{\bfseries ArcheoReport}\\
	[2mm]
	\line(1,0){200}\\
	[1.5cm]
	\textsc{\LARGE University College London}\\
	\textsc{\normalsize Department of Computer Science}\\
	\textsc{\normalsize COMP103P Application Project}\\
	\textsc{\normalsize Team38}\\
	[5cm]
	\end{center}
	\begin{flushright}
	{\large Authors: \\}
	Mohammad Hossein Afsharmoqaddam\\
	Varun Mathur
	\end{flushright}
\end{titlepage}
\tableofcontents

\newpage
\section{Abstract}\label{sec:abstract}
Our application project was assigned to the Egyptian Museum of Turin, Italy. We had to develop an exhibition based management tool which would be used by the museum professionals when they are hosting exhibitions outside of their local location. It is essentially an effective tool for museums with archaeological collections.  
\par
The application is designed in such a way where the user is able to create a full ``condition report''  about the state of preservation of the artefacts. ``A condition report'' is a detailed description of the condition of a museum artefact typically produced on the occasion of loans for exhibitions, special handling sessions, packing or restoration projects. 
\par
Additionally, the user is then able to generate a pdf file after filling out the form and save it to their database for further references and creating new forms. To expand, the app has a simple and user friendly interface with various field and dropdown menus and controlled vocabularies and it is able to acquire multiple images of the artefacts. The application allows the user to either upload a photo from the directory of their device or to take a photo from the camera provided on their device. After uploading the photo they are able to annotate the photos using their fingers or a tablet pen. 
\par
Furthermore, the application provides two view screens which are, the ``view forms'' and ``view gallery''. Both of these screens showcase and group their data and the user is able to filter the data by the filtering options provided. 




\newpage
\section{Context}\label{sec:context}

\subsection{Background}
Our team has been in contact with Paolo Del Vesco, a UCL honorary researcher and a curator at the museum and Marco Rossani the registrar of the museum.  The Egyptian Museum of Turin also known as ``Museo delle Antichita'' is the only museum other than the Cairo museum that is dedicated solely to Egyptian art and culture. According to the museums website ``the collections that make up today’s Museum were enlarged by the excavations conducted in Egypt by the Museum’s archaeological mission between 1900 and 1935 (a period when finds were divided between the excavators and Egypt).''

\subsection{Purpose}\label{sec:purpose}
As discussed in the Abstract the museum loans artefacts for exhibitions, have special handling sessions and packing or restoration projects. Therefore, the museum needs to be able to keep track of each artefact and be able to check the artefacts conditions before and after the sessions. 
\par
However, majority of these actions have been paper form based and this application fundamentally will be digitalising the records of the artefacts. By digitalising the system we have brought many advantages which were not possible before in the paper based system which will be discussed below.  

\subsubsection{Easy Access}
From the moment a form is created it becomes accessible from any of the tablets which has the application downloaded. By having a paper based system, a paper file cannot be accessing by another employee at the same time and it is usually housed in file or cabinet which access must be requested.

\subsubsection{Filtering and Searchable Text}
The application allows the user to be able to locate and view forms based on their specific exhibition date and also has a gallery screen which provides all of the photos of the artefacts which can be filtered by the different parameters provided. This is extremely useful since if a client request a form, the museum will be able easily search the form required from their database.

\subsubsection{Cost Savings}
The switch to digitalising a system saves money for many establishments. By having a digitalised system we are minimising the cost of papers, secure file cabinets that the files need to be archived in and adding this to the cost of filing clerks and the downtime required to find specific forms the cost increases substantially.



\newpage
\section{Team Member Summary}

\subsection{Mohammad Hossein Afsharmoqaddam}
Mo did not have any prior android development experience, therefore this was a new area for him to explore. He previously has had experience with C and Java from his university courses and basic web development. He has always liked frontend development and design, therefore his responsibilities were mainly the User Interface elements, navigation and the overall Logic of the application. 

\subsection{Varun Mathur}
Varun has 4 years of Android experience. He has written a few apps as part of summer programs and internships. Varun did a lot of work on the back end functionality of the app, including implementing data persistence and implementing dynamic views that were populated with this data. This consisted of creating classes to represent objects in the system (Reports, Images, Annotations, Defects, Exhibitions), and then implementing the logic to store and retrieve this information and then present this data in the correct views. Additionally, Varun implemented the photo capture and annotation functionality that is present in the app as well as the “filterable” gallery.

\subsection{Rouzbeh Mehregan}





\newpage
\section{Work Plan (GANTT CHART)}
To be as efficient and productive as possible and a Gantt Chart offers many advantages we decided to use this method to enhance our communication, and to be able to see our project over the long term and to track the results of each task. 
\par
In a glance we were able to keep track of incoming tasks, and tasks that remained to be completed, therefore we avoided any completion confusion. Furthermore, by being able to look ahead we were able to effectively allocate resources and tasks to each member. 

\begin{figure}[h]
\begin{center}
\includegraphics[width=1.0\textwidth]{ArcheoReportGantt}
\end{center}
\end{figure}

As you can see from the figure, we separated the project into three different areas. The blue colour reprsents our team meetings during the project, the turquoise colour represents the timeline of our early planning, requirements and mock-up stages. The orange colour represents our development and programming phase and the red colour represents the evaluation and the creation of the final report. Additionally, the timeline on top of the chart provides us with the exact duration that each task should be completed. 

\section{Requirements}
\subsection{Project Brief}
Our brief was to design an app for the UCL Institute of Archeaology that would enable them to generate condition reports for artefacts using a tablet app. Additonally, they wanted some additionally functionality including photo capture and annotation, auto completion of data fields using information from Excel files and signature authentication. We were given these specifications by the client in our initial meeting. After this we took all of their requirements for the app and prioritised them based on a cost/necessity basis. Essentially requirements were ranked based on their necessity versus cost of implementation. When we finished we showed our analysis to the clients who then suggested changes. Finally we ended up with a completed MoSCoW analysis of the requirements.

\subsection{MoSCoW Requirements}
\subsubsection{Must Have}
\begin{description}
\item [Report Generation - (PDF Generation)]
Condition reports for artefacts must be output by the app in PDF format. The format and contents of the report should be identical to the current form.

\item [Report Data Should Be Saved for Subsequent Reports]
The client said that when an item is moved into an exhibition, a condition report is generated. Then after the exhibition another report is done, with reference to the prior one.

\item [Condition Reports Must Be Grouped by Exhibition]
This entails a higher level menu wherein the user can create and manage exhibitions. Then within the context of one exhibition the user can manage condition reports.

\item [Image Selection Wizard Screen]
When the user chooses to add a photo to a report, the menu should allow them to choose images from file directory or capture and annotate a new photo. Additionally, user should be able to mark a photo as a packing photo.

\item [Photo Capture]
The app must allow the user to take photos of artefacts. These photos should be stored for later reference. Most likely cloud storage.

\item [Photo Annotation]
The app must facilitate annotating images to mark defects on artefacts. These annotations must be classified, and linked to a textual description. 

\item [Auto-Fill Form]
The text inputs on the form will fill themselves in from data stored in an excel file once the user types in an item’s inventory number. 

\item [Storage of Descriptions for Annotations - Links to Visual Annotations]
Images will have to be categorised by their defects, thus annotations will have concrete classifications. Additionally, annotations will be linked to textual descriptions of the defect.

\item [Picture Browsing with Defect Classification]
Pictures will be classified based on defects present in them. User must be able to search a gallery of images, and search by defect.

\item [Import Excel data]
The user should be able to import data in the form of an excel document. This data will be used to auto complete fields in the condition report form. 

\end{description}

\subsubsection{Should Have}
\begin{description}
\item [Zooming functionality on annotation drawing screen]
User should be able to zoom in while drawing annotations such that they can draw with greater detail and precision.
\end{description}
\subsubsection{Could Have}
\begin{description}
\item [Signature]
The user could sign off on reports using the tablet in order to verify and authenticate their identity.

\item [Login/Identification (Could replace signature)]
As an alternative to signatures, users could sign in using a username and password to verify identity. Also enhances security as users will have to be logged in to use the app.

\item [Printing]
Printing condition reports is another feature that could be implemented. Android has this functionality.
\end{description}
\subsubsection{Will Not Have}


\subsection{Glossary / Data Dictionary}
\begin{description}
\item [Condition Report] The clients currently conduct condition reports on museum artefacts in transit. In these reports, they record information about the condition of the artefact including any \textbf{defects} that are present. Additionally they note information about the way the item has been packed as well as general information about the artefact itself. Artefacts are identified using their inventory number which is stored in the report

\item [Exhibition] The clients would like to group their reports by exhibition. That is, the exhibition that the artefact is in transit to/from. Each exhibition has the following information: Name, Location, Start Date, and End Date.

\item [Defect] The clients have a set list of defects which they try to identify and record when doing condition reports on artefacts. In the context of the app, the user must be able to select defects from a pre set list when creating a condition report.

\item [Annotation] The clients wanted to be able to draw annotations on photos of artefacts and associate an annotation with a specific defect and then have those annotated photos saved on the device. In this case, annotations are just drawings, but they must be linked to a defect. Additionally, an annotated image must store the defects that are associated with the annotations on the images. This way, in the gallery section of the app, photos may be filtered by the defect that they depict. 
\end{description}
\section{Design}
\subsection{Rationale for Using the Model-View-Controller Framework}
We decided to follow an MVC approach to the solution for a variety of reasons. First, Android applications are programmed in JAVA, an object oriented programming language. Moreover, due to the nature of our requirements an object oriented approach suited our solution. Based on our analysis and understanding of the application brief we translated 3 real world objects into JAVA classes: Reports, Exhibitions, and Annotated Images. These objects would be the models in the MVC framework.\\

Android development lends itself to the MVC framework in that Views are created using XML, and then populated with information from Models through Activity classes. Thus in this case, we would create are views using XML, and then have Activities work as the controllers in the system, handling user input and managing the exchange of information between model and view and vice versa. 
\subsection{Models}
\subsubsection{Exhibition Class}
Due to the nature of our clients' work, all condition reports are conducted within the context of an exhibition. In the app, this would be reflected in the user interface, as all condition reports would be generated within the higher context of an exhibition. Thus we created an exhbition class in order to store information about specific exhbitions including: the name, the location, and the start and end dates of the exhibition.
\subsubsection{Report Class}
The report class maintains all of the information from a single condition report conducted on a single artefact. The report therefore must encapsulate every bit of information that is entered from the condition report generation screen. Moreover, the report class contains a reference to an exhibition object which is its contextual exhibition.
\subsubsection{Annotated Image Class}
One of the clients' most important requirements was to be able to capture photos of artefacts and then annotate the photos to illustrate defects in the item. Photo capture and annotation would be done under the context of a specific condition report (i.e. the user would capture and annotate photos of the artefact while conducting the condition report on the same item). Thus these images would have to be linked somehow to the report. Moreover, the annotations would be linked to defects, and these defects would have to be stored along with the image. This warranted the creation of an AnnotatedImage class which contains a list of defects, a reference to its contextual report, and a file path to the image itself on the device.

\subsubsection{UML}
TODO: UML GOES HERE

\subsection{Views}
The user must be able to both create and view models in the system. Thus we reasoned that views could be generally split into two categories: \textit{viewers} and \textit{creators}. Thus in our implementation, each model has an associated \textit{viewer} and \textit{controller}. The role of a  \textit{viewer} view is to display information from a model or models to the user, while a \textit{creator} view provides all the user input elements to allow for the construction of a model. All views have associated controllers which either bind data from the model to populate the view, or handle user input and take that data to create a model.


\subsubsection{Viewers}
\label{sec:Viewers}

\paragraph{Exhibition Viewer}
This was the highest level screen. Exhibition objects are loaded from the database and passed into a ListView. Each ListItem displays the name, location, and dates of each exhibition. Clicking on an exhibition in the list leads to the ``Report Viewer'' screen with the exhibition passed as context.

\paragraph{Report Viewer}
This screen loads up Reports from the database under the context of the higher level exhibition. This is achieved using a simple database query (explained in Persistance section). The reports are loaded into a ListView. Each item displays the inventory number of the artefact and the date the report was created. Clicking on a report will open the corresponding PDF of the report in the device's native document viewer.

\paragraph{Image Viewer (Gallery)}
This screen presents the user with a grid of annotated images loaded from the device. Clicking an image will open it full screen in the device's native image viewer. The user can also choose to filter images by Exhibition, Report and Defect. This is achieved once again using database queries. Once the correct AnnotatedImage objects are loaded, their file paths are lazily loaded into an ImageView in each GridItem so as not to slow down the interface. 

\subsubsection{Creators}
\label{sec:creators}

\paragraph{Exhibition Creator}
View with 4 input elements to allow the user to create an Exhibition object.

\paragraph{Report Creator}
Replication of the paper condition report form. Full page view with inputs for all the fields of a condition report, allowing the user to create Report objects. Additionally, this view had a button which allowed the user to attach photos to the report. Adding an image would give the option to annotate it and thus lead the user to a view where they could ``create'' an annotated image.

\paragraph{Annotated Image Creator}
This view allowed the user to annotate images from the device or from the camera. The user is presented with some options to change brush width and colour. Additionally, the user can select which defect they want to associate with their annotations. When the user is finished, the result is a new Annotated Image object which is saved on the device. \\

In order to achieve the annotation functionality a custom class was created, extending Android's native ImageView. This new class, called AnnotationView dsiplays an image and detects user touches to draw annotatations on top of the image. The annotated photo can be obtained in Bitmap form by retrieving the object's drawing cache. 

\subsubsection{Controllers}
\label{sec:Controllers}

In this system, controllers were implemented as Android Activities. The Activity class in the Android environment encapsulates a user's interactions with a single view. Thus each view in the system has an associated Activity which it is bound to. Within each Activity lies the logic which binds data to elements in the view, or generates and updates models from data input in the user interface. Additionally, the Activity is responsible for actions like generating PDF documents, saving annotated images to file, and updating views based on user input. 

\paragraph{Specific Implementation Details}
PDF generation was achieved using the built-in PDFDocument API present in the Android SDK. In the CreateReport Activity, upon report completion a new Report object is generated with the input data. This object is then passed to a method which generates the PDF version of the report. This is achieved by creating a containing view object (a LinearLayout) and then adding TextViews containing textual data from the report as children to this container. Additionally, a maximum of 4 ImageViews are added to the container and supplied with Annotated Images from the report. Everytime a view is added to the container, its coordinates must be specified such that they fit into the 595 x 842 (A4 size) canvas. Then the LinearLayout is ``drawn'' onto the canvas of a PDFDocument object, and the corresponding PDF file is saved onto the device's external storage in the directory: \textit{ArcheoReport/Reports/<Exhibition Name>/<Report Inventory Number>.pdf} \\

In the image annotation Activity, the controller logic is responsible for responding to user input and changing the parameters of the annotations. There are three parameters for the annotation view: annotation color, annotation size, and defect classification. The controller listens for input on these menus and then updates the AnnotationView to change the parameters. Additionally, there is an ``eraser'' button. When this is toggled, the controller updates the AnnotationView to erase annotations rather than draw new ones. When the user finishes the annotation, the annotated images in saved to file in the following directory: \textit{ArcheoReport/Images/<Exhibition Name>/<Report Inventory Number>_annotated_<timestamp>.pdf} \\


\subsubsection{Model Persistance}
A key part of the implementation was saving objects in the database when they were created so that they could be loaded and presented to the user in the interface. Android has built-in database functionality: there is an API to allow the programmer to store data in an SQLite database. Initially we were going to use this API to store the objects in the application. However, we found a third party library called SugarORM which vastly simplified this process. SugarORM works as follows: Objects which are to be persisted must extend the ``SugarRecord'' class. Then when an object is created, ``SugarRecord.save()'' must be called on the object to save the object in the database. The library saves all instance variables of the object in a row of a table named after the class. Thus the programmer is completely removed from the process of actually interacting with the database. Database queries can also be conducted on these tables, with references to the members of the class. Additionally, each object is assigned a unique ID which can be used to retreive it from the database. Queries will return \textit{Plain Old JAVA Objects} which can then be used right away in the application.

\section{Testing and Installation}
Our development schedule was iterative and driven by producing protoypes at various milestones. We resolved to create a protoype which met all the requirements to a standard that we were satisfied with. Then we sent it to the client to get their feedback. Then began a cycle where we would implement their feedback, send them a new build and continuously fine tune the application to the point where the client was satisfied. \\

The reason we did this was because our development time was limited and so was our manpower. We decided that the fastest way to create a working product would be to follow a development schedule that emphasised building partially complete, but running prototypes and getting as much feedback from the client as we could, as often as we could. Each build would introduce a new feature or small set of features that the client could test and evaluate, then they would tell what to change. We would change it, add more features and repeat the process. This way we minimised the time spent implementing features the wrong way. \\

Each prototype would be tested by us before sending it to the client. Because each prototype typically introduced a small set of new features, testing on each incremental build consisted of testing that the new feature worked and integrated well with the rest of the app. Once testing was complete, we would send the new build to the client via email. 



\end{document}
